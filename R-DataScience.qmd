---
title: "R Notes"
format: html
editor: visual
---

## Manipulating Data - dplyr

**Background Information about dplyr:**

plyr (split-apply-combine strategy for data analysis) is the root of dplyr. Plyr covers a diverse set of inputs and outputs (eg. arrays, data frames, lists), dplyr only focuses on data frames, "tibbles".

**Using filter to subset data row-wise:**

We take dataset gapminder for example, canada \<- gapminder \[241:252, \]. This is a terrible idea, because 1) It's not self-documenting, there's no special about rows 241 to 252 and 2) It's fragile, if someone changes the row order, then line of code produce different results. Instead, you can use filter.

```{r}
# load tydyverse to load dplyr
library (tidyverse)
# load sample dataset - gapminder
library (gapminder)
# load sample dataset - flights
library(nycflights13)
```

```{r}
# Filter takes logical expressions and returns the rows which all are TRUE
# Filter lifeExp < 29
filter (gapminder, lifeExp < 29)
# Filter Rwanda coutry with year > 1979
filter (gapminder, country == "Rwanda", year > 1979)
# Filter both Rwanda and Afghanistan countries
filter (gapminder, country %in% c("Rwanda", "Afghanistan"))
```

### Row-wise

**Using select to subset data row-wise:**

```{r}
# select () allows to subset the data on varaibles or columns
select(gapminder, year, lifeExp)
# pipe operator with select ()
gapminder %>%
  select(year, lifeExp) %>%
  head(4)
# Now using both select() and filter ()
gapminder %>%
  filter(country == "Cambodia") %>%
  select(year, lifeExp)
```

**Using arrange() to row-order data in a principled way:**

```{r}
# arrange() reorders the rows in a data frame.Imagine you wanted this data ordered by year then country, as opposed to by country then year.
my_gap %>%
  arrange(year, country)
# Want just the data from 2007, sorted on life expectancy
my_gap %>%
  filter(year == 2007) %>%
  arrange(lifeExp)
# desc() for descending order
my_gap %>%
  filter(year == 2007) %>%
  arrange(desc(lifeExp))
```

### Column-wise

**Using mutate() to add new variables:**

```{r}
# mutate() is a function that defines and inserts new variables into a tibble
my_gap %>%
  mutate(gdp=pop*gdpPercap)

ctib <- my_gap %>%
  filter(country=="Canada")

my_gap <- my_gap %>%
  mutate(tmp=rep(ctib$gdpPercap, nlevels(country)),
         gdpPercapRel = gdpPercap/tmp,
         tmp = NULL)
my_gap
summary(my_gap$gdpPercapRel)
# Thus, I perceive Canada to be a “high GDP” country. 
```

**Rename variables - rename():**

```{r}
# rename (new name = old name)
my_gap %>%
  rename(life_exp = lifeExp,
         gdp_percap = gdpPercap,
         gdp_percap_rel = gdpPercapRel)

```

**Select certain columns - select():**

```{r}
# selcet (new name = old name)
my_gap %>%
  filter(country == "Burrundi", year >1996) %>%
  # select() can also use to rename the varaibles you request to keep
  select(yr=year, lifeExp, gdpPercap) %>%
  # this helps hoist a variable (gdpPercap) up to the front of the tibble.
  select(gdpPercap, everything())
# starts_with("abc"): matches names that begin with “abc”.
# ends_with("xyz"): matches names that end with “xyz”.
# contains("ijk"): matches names that contain “ijk”.
# num_range("x", 1:3): matches x1, x2 and x3.
```

**Move variables to the front - relocate():**

```{r}
# Use relocate() to move variables around. You might want to collect related variables together or move important variables to the front.
flights %>%
  relocate(time_hour, air_time)
```

**group_by() & summarize():**

```{r}
# group_by() adds extra structure to your dataset, grouping information which lays the groundwork for computations within the groups
# summarize() takes a dataset with n observations, computes requested summaries, and return a dataset with 1 observation 
my_gap %>%
  group_by(continent) %>%
  summarize(n=n())
# Option 2 - tally() function is a convenience function that knows to count rows
my_gap %>%
  group_by(continent) %>%
  tally()
# Option 3 - count() function is an even more convenient function that does both grouping and counting.
my_gap %>%
  count(continent)
# Differentiate by continents, count number of rows for each continent as n by using n() and count how many distinct countries in each continent as n_countries by using n_dictinct()
my_gap %>%
  group_by(continent) %>%
  summarize(n=n(),
            n_countries = n_dictinct(country))
```

**General Summarization:**

The functions you'll apply within `summarize()` include classical statistical summaries, like `mean()`, `median()`, `var()`, `sd()`, `mad()`, `IQR()`, `min()`, and `max()`. Remember they are functions that take n inputs and distill them down into 1 output.

```{r}
# Compute the average life expectancy by continent
my_gap %>%
  group_by (continent) %>%
  summarize(avg_lifeExp = mean(lifeExp))

# Summarize_at() applies the same summary function(s) to multiple variables.
# summarize_at(.tbl, .vars, .funs, ..., .cols = NULL)
# Compute average and median life expectancy and GDP per capita by continent by year…but only for 1952 and 2007.
my_gap %>%
  filter(year %in% c(1952, 2007)) %>%
# apply a summarise function to calculate the mean of a variable, without group_by, it will calculate the mean for that variable across the entire dataset. With group_by(continent, year), it calculates the mean for each combination of continent and year separately.
  group_by (continent, year) %>%
  summarize_at(vars(lifeExp, gdpPercap), list(~mean(.), ~median(.)))

# Let’s focus just on Asia. What are the minimum and maximum life expectancies seen by year.
my_gap %>%
  filter(continent == "Asia") %>%
  group_by(year) %>%
  summarize(min_lifeExp = min(lifeExp), max_lifeExp = max(lifeExp))
```

**Others Important Points:**

```{r}
# Identified the class of a dataframe
class (gapminder)
# To turn any dataframe into a tibble use as_tibble ()
as_tibble(iris)
# head () allows you to check first couple of lines of dataframe
head (gapminder)
head (gapminder,3)
# Pipe Operator  
gapminder %>%
  head (3)
# Creating a copy of dataset before making changes on that to prevent damaging
my_gap <- gapminder
# rep(x, times) is a function used to repeat the elements of x, times number of times.
my_gap <- my_gap %>%
  mutate(tmp=rep(ctib$gdpPercap, nlevels(country)))
# & represents and, | represents or
# na.rm = TRUE VS. na.rm = FALSE
# na.rm = TRUE: tells the function to remove (or ignore) the NA values when performing calculations or operations.
# na.rm = FALSE: this means that the function will not remove the NA values. In many cases, this will result in the function returning NA if there are any NA values in the data. 
```

## Graphing - ggplot

ggplot2 is one of the package of tidyverse.

```{r}
print(mpg)
```

### Scatter-PLots

```{r}
# To plot mpg, run this code to put displ (car's engine size, in litres) on the x-axis and hwy (car's fuel efficiency on the highway) on the y-axis:
# The graphing template for making graphs with ggplot2
# ggplot(data=<DATA>) + 
# <GEOM_FUNCTION> (mapping = aes(<MAPPINGS>))
ggplot(data=mpg) + 
  geom_point(mapping = aes(x=displ, y=hwy))
# "hwy"和"displ"的值被取整，因此点会出现在网格上，许多点彼此重叠。这个问题被称为过度绘制（overplotting). You can avoid this gridding by setting the position adjustment to “jitter”. position = "jitter" adds a small amount of random noise to each point.
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy), position = "jitter")
# Mapping the aesthetics in your plot to the variables in your dataset; in aes, map the colors of your points to the class variable to reveal the class of each car.
ggplot(data=mpg) + 
  geom_point(mapping = aes(x=displ, y=hwy, color=class))
# Mapped class to the size aesthetic in the same way. 
ggplot(data=mpg) + 
  geom_point(mapping = aes(x=displ, y=hwy, size=class))
# alpha= controls the transparency of the points
ggplot(data=mpg) +
  geom_point(mapping = aes(x=displ, y=hwy, alpha=class))
# shape= controls the transparency of the points
ggplot(data=mpg) +
  geom_point(mapping=aes(x=displ, y=hwy, shape=class))
```

Set aesthetic properties of your geom manually, color = ? outside the aes()

```{r}
# set aesthetic properties of your geom manually
ggplot(data=mpg) +
  geom_point(mapping=aes(x=displ, y=hwy), color = "blue")

```

Facets, split your plot into **facets**

```{r}
# facet_wrap() to split plots
ggplot(data=mpg) +
  geom_point(mapping=aes(x=displ, y=hwy)) +
  facet_wrap(~class, nrow=2)
# facet_grid() to split the combination of two variables
ggplot(data=mpg) +
  geom_point(mapping=aes(x=displ, y=hwy)) +
  facet_grid(drv~cyl)
```

### Line plots

A **geom** is the geometrical object that a plot uses to represent data. People often describe plots by the type of geom that the plot uses.

```{r}
# Point
ggplot(data=mpg) +
  geom_point(mapping=aes(x=displ, y=hwy))
# Smooth Lines
ggplot(data=mpg) +
  geom_smooth (mapping=aes(x=displ, y=hwy))
# For lines, you could set the linetype of a line
ggplot(data=mpg) +
  geom_smooth (mapping=aes(x=displ, y=hwy, linetype=drv))
# For lines, you could set group/color of a line
ggplot(data=mpg) +
  geom_smooth (mapping=aes(x=displ, y=hwy, group=drv))
ggplot(data=mpg) +
  geom_smooth (mapping=aes(x=displ, y=hwy, color=drv))
```

To display multiple geoms in the same plot, add multiple geom functions to [`ggplot()`](https://ggplot2.tidyverse.org/reference/ggplot.html):

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) +
  geom_smooth(mapping = aes(x = displ, y = hwy))
# To avoid repetition by passing a set of mappings to ggplot()
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_point() +
  geom_smooth()
# One plot different
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_point(mapping = aes(color = class)) + 
  geom_smooth()
# Filter out part of the data
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_point(mapping = aes(color = class)) + 
  geom_smooth(data = filter(mpg, class == "subcompact"), se = FALSE)
```

### Histograms

```{r}
head(diamonds)
ggplot(data=diamonds) +
  geom_bar(mapping=aes(x=cut))
# You might want to override the default mapping from transformed variables to aesthetics. For example, you might want to display a bar chart of proportion, rather than count:
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, y = stat(prop), group = 1))
# There’s one more piece of magic associated with bar charts. You can colour a bar chart using either the colour aesthetic, or, more usefully, fill:
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, colour = cut))
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = cut))
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = clarity))
```

### Boxplots

```{r}
ggplot(data = mpg, mapping = aes(x = class, y = hwy)) + 
  geom_boxplot()
# coord_flip() switches the x and y axes.
ggplot(data = mpg, mapping = aes(x = class, y = hwy)) + 
  geom_boxplot() +
  coord_flip()
```
